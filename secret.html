<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>25 Mini Games — All-in-One</title>
  <style>
    :root{--bg:#0f1724;--card:#0b1220;--muted:#9aa6b2;--accent:#7dd3fc}
    *{box-sizing:border-box;font-family:Inter,Segoe UI,Arial,sans-serif}
    body{margin:0;background:linear-gradient(180deg,#071028 0,#071a2a 100%);color:#e6eef6}
    header{padding:12px 18px;display:flex;align-items:center;gap:12px}
    header h1{font-size:18px;margin:0}
    .layout{display:grid;grid-template-columns:320px 1fr;gap:14px;padding:14px}
    nav{background:rgba(255,255,255,0.02);padding:12px;border-radius:12px;height:calc(100vh - 90px);overflow:auto}
    .game-list button{width:100%;text-align:left;padding:10px;border-radius:8px;border:none;background:transparent;color:var(--muted);margin-bottom:6px}
    .game-list button.active{background:rgba(125,211,252,0.08);color:var(--accent)}
    main{padding:16px;background:rgba(255,255,255,0.02);border-radius:12px;height:calc(100vh - 90px);overflow:auto}
    .topbar{display:flex;gap:12px;align-items:center}
    .settings{margin-top:12px;background:rgba(255,255,255,0.01);padding:12px;border-radius:8px;color:var(--muted)}
    .canvas{margin-top:12px;background:#031021;padding:12px;border-radius:8px;min-height:420px;display:flex;align-items:center;justify-content:center}
    label{display:block;font-size:13px;margin-bottom:6px}
    input,select{padding:8px;border-radius:6px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:inherit}
    footer{padding:12px;text-align:center;color:var(--muted);font-size:13px}
    .row{display:flex;gap:8px}
    canvas.game-canvas{background:#000;border-radius:8px}
    .small{font-size:12px}
    .flex{display:flex;gap:8px;align-items:center}
  </style>
</head>
<body>
  <header>
    <h1>25 Mini Games — All-in-One</h1>
    <div style="color:var(--muted);font-size:13px">Pick a game, tweak settings, press Start</div>
  </header>

  <div class="layout">
    <nav>
      <div class="game-list" id="gameList"></div>
      <div class="settings" id="globalSettings">
        <label>Canvas Width
          <input id="canvasWidth" type="number" value="640" />
        </label>
        <label>Canvas Height
          <input id="canvasHeight" type="number" value="360" />
        </label>
        <label>Scale
          <select id="canvasScale"><option>1</option><option>1.5</option><option>2</option></select>
        </label>
        <div style="margin-top:8px" class="row">
          <button id="applyCanvas">Apply</button>
          <button id="resetSettings">Reset</button>
        </div>
      </div>
    </nav>

    <main>
      <div class="topbar">
        <div class="flex">
          <button id="startBtn">Start</button>
          <button id="stopBtn">Stop</button>
        </div>
        <div style="margin-left:auto;color:var(--muted);font-size:13px">Active: <span id="activeGameName">None</span></div>
      </div>

      <div class="settings" id="gameSettingsContainer">
        <div id="gameSettings"></div>
      </div>

      <div class="canvas" id="canvasWrap">
        <canvas id="gameCanvas" class="game-canvas" width="640" height="360"></canvas>
      </div>

      <div id="extraUI"></div>
    </main>
  </div>

  <footer>
    Built-in 25 mini-games • Settings are live and flexible • Single-file HTML
  </footer>

  <script>
  // --- Utilities ---
  const qs = s => document.querySelector(s);
  const qsa = s => Array.from(document.querySelectorAll(s));
  const canvas = qs('#gameCanvas');
  const ctx = canvas.getContext('2d');
  let animationId = null;

  // --- Game registry ---
  const games = [];
  function registerGame(id, name, defaults, setupFn){
    games.push({id,name,defaults,setupFn});
  }

  // --- Simple games (25) ---
  // We'll implement concise playable versions with flexible settings.

  // 1) Clicker
  registerGame('clicker','Clicker (Score per Click)',{clickValue:1,autoPerSec:0}, function(state){
    state.score=0; state.last=0; state.auto=state.opts.autoPerSec;
    return {
      draw(){ctx.clearRect(0,0,canvas.width,canvas.height);ctx.fillStyle='#0f1724';ctx.fillRect(0,0,canvas.width,canvas.height);ctx.fillStyle='white';ctx.font='22px monospace';ctx.fillText('Score: '+state.score,20,40);ctx.fillText('Click area below',20,80);ctx.fillStyle='#7dd3fc';ctx.fillRect(50,120,canvas.width-100,180);ctx.fillStyle='#001';ctx.fillText('CLICK',canvas.width/2-30,220);
      },
      pointerdown(){state.score+=Number(state.opts.clickValue);
      },
      step(dt){ state.last+=dt; if(state.last>1000){ state.score+=state.auto; state.last=0 } }
    }
  });

  // 2) Reaction Time
  registerGame('reaction','Reaction Time',{minDelay:1000,maxDelay:3000}, function(state){
    state.wait=true; state.startTime=0; state.display='Wait...'; state.timer=0; state.target= randomRange(Number(state.opts.minDelay),Number(state.opts.maxDelay));
    function reset(){ state.wait=true; state.target=randomRange(Number(state.opts.minDelay),Number(state.opts.maxDelay)); state.timer=0; state.display='Wait...'; }
    return {
      draw(){ctx.clearRect(0,0,canvas.width,canvas.height);ctx.fillStyle='white';ctx.font='24px monospace';ctx.fillText(state.display,20,120);},
      step(dt){ if(state.wait){ state.timer+=dt; if(state.timer>=state.target){ state.wait=false; state.startTime=performance.now(); state.display='GO! Click!'} } },
      pointerdown(){ if(state.wait){ state.display='Too soon!'; reset(); }else{ const r=performance.now()-state.startTime; state.display='Reaction: '+Math.round(r)+'ms'; reset(); } }
    }
  });

  // 3) Tic-Tac-Toe
  registerGame('tictactoe','Tic-Tac-Toe',{ai:'off'}, function(state){
    state.grid=[0,0,0,0,0,0,0,0,0]; state.turn=1; state.gameOver=false; state.winner=0;
    function check(){ const g=state.grid; const lines=[[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]]; for(const l of lines){ const a=g[l[0]]; if(a && a===g[l[1]] && a===g[l[2]]) return a } if(g.every(x=>x)) return 0; return null }
    return {
      draw(){ctx.clearRect(0,0,canvas.width,canvas.height);const w=canvas.width;const h=canvas.height;ctx.strokeStyle='#7dd3fc';ctx.lineWidth=4;const s=Math.min(w,h)-40;const ox=(w-s)/2, oy=(h-s)/2;const cell=s/3;ctx.strokeRect(ox,oy,s,s);for(let i=1;i<3;i++){ctx.beginPath();ctx.moveTo(ox+i*cell,oy);ctx.lineTo(ox+i*cell,oy+s);ctx.moveTo(ox,oy+i*cell);ctx.lineTo(ox+s,oy+i*cell);ctx.stroke();}
        ctx.fillStyle='white';ctx.font='36px monospace';for(let i=0;i<9;i++){const r=Math.floor(i/3), c=i%3;const val=state.grid[i]; if(val){ctx.fillText(val===1? 'X':'O',ox+c*cell+cell/2-12,oy+r*cell+cell/2+12)} }
        if(state.gameOver) ctx.fillText(state.winner===0? 'Draw':'Winner: '+(state.winner===1?'X':'O'),20,30);
      },
      pointerdown(e){ if(state.gameOver) return; const rect=canvas.getBoundingClientRect(); const x=e.clientX-rect.left, y=e.clientY-rect.top; const w=canvas.width,h=canvas.height;const s=Math.min(w,h)-40;const ox=(w-s)/2, oy=(h-s)/2; if(x<ox||y<oy||x>ox+s||y>oy+s) return; const cell=s/3; const c=Math.floor((x-ox)/cell), r=Math.floor((y-oy)/cell); const idx=r*3+c; if(state.grid[idx]) return; state.grid[idx]=state.turn; const ch=check(); if(ch!==null){ state.gameOver=true; state.winner=ch; } state.turn=3-state.turn; }
    }
  });

  // 4) Rock Paper Scissors
  registerGame('rps','Rock Paper Scissors',{bestOf:3}, function(state){ state.msg='Choose'; return {
    draw(){ctx.clearRect(0,0,canvas.width,canvas.height);ctx.fillStyle='white';ctx.font='22px monospace';ctx.fillText(state.msg,20,40);ctx.fillText('Click R / P / S buttons below',20,80)},
    ui(){ return `<div style="margin-top:8px" class="row"><button data-move="R">Rock</button><button data-move="P">Paper</button><button data-move="S">Scissors</button></div>` }
  }});

  // 5) Snake (simple)
  registerGame('snake','Snake',{speed:8}, function(state){
    const cell=16; state.snake=[{x:5,y:5},{x:4,y:5},{x:3,y:5}]; state.dir={x:1,y:0}; state.food={x:10,y:7}; state.acc=0; state.score=0;
    function placeFood(){ state.food={x:Math.floor(Math.random()*(Math.floor(canvas.width/cell)-2))+1,y:Math.floor(Math.random()*(Math.floor(canvas.height/cell)-2))+1} }
    return {
      draw(){ctx.clearRect(0,0,canvas.width,canvas.height);ctx.fillStyle='#0f1724';ctx.fillRect(0,0,canvas.width,canvas.height);ctx.fillStyle='lime'; for(const s of state.snake) ctx.fillRect(s.x*cell,s.y*cell,cell-1,cell-1); ctx.fillStyle='red'; ctx.fillRect(state.food.x*cell,state.food.y*cell,cell-1,cell-1); ctx.fillStyle='white'; ctx.fillText('Score: '+state.score,10,20)},
      step(dt){ state.acc += dt/ (1000/Number(state.opts.speed)); if(state.acc>=1){ state.acc=0; const head={x:state.snake[0].x+state.dir.x,y:state.snake[0].y+state.dir.y}; if(head.x<0||head.y<0||head.x>Math.floor(canvas.width/cell)||head.y>Math.floor(canvas.height/cell) || state.snake.some(s=>s.x===head.x&&s.y===head.y)){ state.snake=[{x:5,y:5},{x:4,y:5},{x:3,y:5}]; state.score=0; state.dir={x:1,y:0}; placeFood(); return } state.snake.unshift(head); if(head.x===state.food.x && head.y===state.food.y){ state.score++; placeFood(); } else state.snake.pop(); } },
      keydown(e){ if(e.key==='ArrowUp') state.dir={x:0,y:-1}; if(e.key==='ArrowDown') state.dir={x:0,y:1}; if(e.key==='ArrowLeft') state.dir={x:-1,y:0}; if(e.key==='ArrowRight') state.dir={x:1,y:0}; }
    }
  });

  // 6) Pong
  registerGame('pong','Pong',{paddleSpeed:6,ai:'on'}, function(state){
    state.p1=canvas.height/2; state.p2=canvas.height/2; state.ball={x:canvas.width/2,y:canvas.height/2,vx:4,vy:2}; state.score1=0; state.score2=0;
    return {
      draw(){ctx.clearRect(0,0,canvas.width,canvas.height);ctx.fillStyle='white';ctx.fillRect(10,state.p1-30,10,60);ctx.fillRect(canvas.width-20,state.p2-30,10,60);ctx.fillRect(state.ball.x-6,state.ball.y-6,12,12); ctx.fillText(state.score1,canvas.width/4,20);ctx.fillText(state.score2,canvas.width*3/4,20)},
      step(dt){ state.ball.x+=state.ball.vx; state.ball.y+=state.ball.vy; if(state.ball.y<0||state.ball.y>canvas.height) state.ball.vy*=-1; if(state.ball.x<30){ if(Math.abs(state.ball.y-state.p1)<40){ state.ball.vx*=-1 } else { state.score2++; state.ball={x:canvas.width/2,y:canvas.height/2,vx:4,vy:2} } } if(state.ball.x>canvas.width-30){ if(Math.abs(state.ball.y-state.p2)<40){ state.ball.vx*=-1 } else { state.score1++; state.ball={x:canvas.width/2,y:canvas.height/2,vx:-4,vy:2} } } // simple AI
        if(state.ball.y>state.p2+6) state.p2+=Number(state.opts.paddleSpeed); if(state.ball.y<state.p2-6) state.p2-=Number(state.opts.paddleSpeed);
      },
      keydown(e){ if(e.key==='w') state.p1-=Number(state.opts.paddleSpeed); if(e.key==='s') state.p1+=Number(state.opts.paddleSpeed); }
    }
  });

  // 7) Breakout (mini)
  registerGame('breakout','Breakout',{rows:3,cols:8}, function(state){
    const pw=80, ph=12; state.px=canvas.width/2-40; state.ball={x:canvas.width/2,y:canvas.height-60,vx:3,vy:-3}; state.bricks=[]; for(let r=0;r<Number(state.opts.rows);r++){ for(let c=0;c<Number(state.opts.cols);c++){ state.bricks.push({x:10+c*(pw+6),y:20+r*(ph+6),w:pw,h:ph,alive:true}) } }
    return {
      draw(){ctx.clearRect(0,0,canvas.width,canvas.height);ctx.fillStyle='white';ctx.fillRect(state.px,canvas.height-40,80,12); ctx.fillRect(state.ball.x-6,state.ball.y-6,12,12); for(const b of state.bricks) if(b.alive){ctx.fillStyle='#7dd3fc';ctx.fillRect(b.x,b.y,b.w,b.h)} },
      step(){ state.ball.x+=state.ball.vx; state.ball.y+=state.ball.vy; if(state.ball.x<0||state.ball.x>canvas.width) state.ball.vx*=-1; if(state.ball.y<0) state.ball.vy*=-1; if(state.ball.y>canvas.height) { state.ball={x:canvas.width/2,y:canvas.height-60,vx:3,vy:-3} }
        for(const b of state.bricks) if(b.alive && state.ball.x> b.x && state.ball.x< b.x+b.w && state.ball.y> b.y && state.ball.y< b.y+b.h){ b.alive=false; state.ball.vy*=-1 }
      },
      pointermove(e){ const rect=canvas.getBoundingClientRect(); state.px = (e.clientX-rect.left)-40; if(state.px<0)state.px=0; if(state.px>canvas.width-80) state.px=canvas.width-80 }
    }
  });

  // 8) Minesweeper (tiny)
  registerGame('mines','Minesweeper',{w:9,h:9,mines:10}, function(state){
    const W=Number(state.opts.w), H=Number(state.opts.h), M=Number(state.opts.mines);
    state.grid = Array(W*H).fill(0).map(i=>({mine:false,rev:false,flag:false,adj:0}));
    // place mines
    let placed=0; while(placed<M){ const idx=Math.floor(Math.random()*W*H); if(!state.grid[idx].mine){ state.grid[idx].mine=true; placed++ }}
    function idx(x,y){return y*W+x}
    for(let y=0;y<H;y++) for(let x=0;x<W;x++){ if(state.grid[idx(x,y)].mine) continue; let c=0; for(let oy=-1;oy<=1;oy++) for(let ox=-1;ox<=1;ox++){ const nx=x+ox, ny=y+oy; if(nx>=0&&ny>=0&&nx<W&&ny<H && state.grid[idx(nx,ny)].mine) c++; } state.grid[idx(x,y)].adj=c }
    function reveal(i){ if(state.grid[i].rev||state.grid[i].flag) return; state.grid[i].rev=true; if(state.grid[i].adj===0 && !state.grid[i].mine){ const x=i%W,y=Math.floor(i/W); for(let oy=-1;oy<=1;oy++) for(let ox=-1;ox<=1;ox++){ const nx=x+ox, ny=y+oy; if(nx>=0&&ny>=0&&nx<W&&ny<H) reveal(idx(nx,ny)) }} }
    return {
      draw(){ctx.clearRect(0,0,canvas.width,canvas.height); const cell=Math.min(canvas.width/W,canvas.height/H); for(let y=0;y<H;y++) for(let x=0;x<W;x++){ const i=idx(x,y); const g=state.grid[i]; const px=x*cell, py=y*cell; ctx.strokeStyle='#123'; ctx.strokeRect(px,py,cell,cell); if(g.rev){ ctx.fillStyle=g.mine?'#f33':'#cde'; ctx.fillRect(px+1,py+1,cell-2,cell-2); if(g.adj) { ctx.fillStyle='black'; ctx.fillText(g.adj,px+cell/2-4,py+cell/2+4) }} else { ctx.fillStyle='#224'; ctx.fillRect(px+1,py+1,cell-2,cell-2); if(g.flag){ ctx.fillStyle='yellow'; ctx.fillText('F',px+cell/2-4,py+cell/2+4) } } } },
      pointerdown(e){ const rect=canvas.getBoundingClientRect(); const x=Math.floor((e.clientX-rect.left)/(canvas.width/W)); const y=Math.floor((e.clientY-rect.top)/(canvas.height/H)); const i=idx(x,y); reveal(i); if(state.grid[i].mine) alert('Boom!'); }
    }
  });

  // 9) Whack-a-Mole
  registerGame('whack','Whack-a-Mole',{holes:6,interval:900}, function(state){ state.holes=Number(state.opts.holes); state.up=-1; state.timer=0; return {
    draw(){ctx.clearRect(0,0,canvas.width,canvas.height); for(let i=0;i<state.holes;i++){ const x=20+i*(canvas.width/state.holes); ctx.fillStyle=i===state.up?'#f80':'#333'; ctx.fillRect(x,canvas.height/2-20,60,60)} ctx.fillStyle='white'; ctx.fillText('Score: '+(state.score||0),10,20)},
    step(dt){ state.timer+=dt; if(state.timer>Number(state.opts.interval)){ state.timer=0; state.up=Math.floor(Math.random()*state.holes); } },
    pointerdown(e){ const rect=canvas.getBoundingClientRect(); const cx=e.clientX-rect.left, cy=e.clientY-rect.top; for(let i=0;i<state.holes;i++){ const x=20+i*(canvas.width/state.holes); if(cx>x&&cx<x+60 && cy>canvas.height/2-20&&cy<canvas.height/2+40){ if(i===state.up){ state.score=(state.score||0)+1; state.up=-1 } } } }
  }});

  // 10) 2048 (tiny)
  registerGame('2048','2048 (simple)',{size:4}, function(state){
    const N=Number(state.opts.size); state.grid=Array(N*N).fill(0);
    function addTile(){ const empt=state.grid.map((v,i)=>v?null:i).filter(v=>v!==null); if(!empt.length) return; state.grid[empt[Math.floor(Math.random()*empt.length)]]=Math.random()<0.9?2:4 }
    addTile(); addTile();
    function drawGrid(){ ctx.clearRect(0,0,canvas.width,canvas.height); const cell=Math.min(canvas.width/N,canvas.height/N)-6; for(let y=0;y<N;y++) for(let x=0;x<N;x++){ const v=state.grid[y*N+x]; ctx.fillStyle=v? '#7dd3fc':'#112'; ctx.fillRect(10+x*(cell+6),10+y*(cell+6),cell,cell); if(v) { ctx.fillStyle='black'; ctx.fillText(v,15+x*(cell+6)+cell/2-8,25+y*(cell+6)+cell/2+8) } } }
    function move(dx,dy){ let moved=false; const Nn=N; if(dx!==0){ for(let y=0;y<Nn;y++){ let line=[]; for(let x=0;x<Nn;x++) line.push(state.grid[y*Nn+x]); if(dx>0) line=line.reverse(); let merged=[]; let out=[]; for(const v of line){ if(v===0) continue; if(out.length && out[out.length-1]===v && !merged[merged.length-1]){ out[out.length-1]*=2; merged[merged.length-1]=true; } else { out.push(v); merged.push(false) } } while(out.length<Nn) out.push(0); if(dx>0) out=out.reverse(); for(let x=0;x<Nn;x++){ if(state.grid[y*Nn+x]!==out[x]) moved=true; state.grid[y*Nn+x]=out[x]; } } }
      if(moved) addTile(); }
    return { draw:drawGrid, keydown(e){ if(e.key==='ArrowLeft') move(-1,0); if(e.key==='ArrowRight') move(1,0); if(e.key==='ArrowUp') move(0,-1); if(e.key==='ArrowDown') move(0,1); } }
  });

  // 11) Slider Puzzle (3x3)
  registerGame('slider','Slider Puzzle',{size:3}, function(state){ const N=Number(state.opts.size); state.size=N; state.tiles=[]; for(let i=0;i<N*N;i++) state.tiles.push(i); state.tiles.sort(()=>Math.random()-0.5); return {
    draw(){ ctx.clearRect(0,0,canvas.width,canvas.height); const cell=Math.min(canvas.width/state.size,canvas.height/state.size); for(let y=0;y<state.size;y++) for(let x=0;x<state.size;x++){ const i=y*state.size+x; const v=state.tiles[i]; ctx.fillStyle=v?'#7dd3fc':'#112'; ctx.fillRect(x*cell+10,y*cell+10,cell-6,cell-6); if(v) ctx.fillText(v, x*cell+cell/2, y*cell+cell/2) } },
    pointerdown(e){ const rect=canvas.getBoundingClientRect(); const x=Math.floor(((e.clientX-rect.left)/canvas.width)*state.size), y=Math.floor(((e.clientY-rect.top)/canvas.height)*state.size); const i=y*state.size+x; const z=state.tiles.indexOf(0); if([i-1,i+1,i-state.size,i+state.size].includes(z)){ state.tiles[z]=state.tiles[i]; state.tiles[i]=0 } }
  }});

  // 12) Hangman (basic)
  registerGame('hangman','Hangman',{word:'javascript'}, function(state){ state.word=String(state.opts.word||'javascript').toUpperCase(); state.guessed=[]; state.wrong=0; return {
    draw(){ ctx.clearRect(0,0,canvas.width,canvas.height); ctx.fillStyle='white'; ctx.font='22px monospace'; let s=''; for(const c of state.word){ s+= state.guessed.includes(c)?c:'_'; s+=' ' } ctx.fillText(s,20,80); ctx.fillText('Wrong: '+state.wrong,20,120) },
    keydown(e){ const k=e.key.toUpperCase(); if(k.match(/[A-Z]/) && !state.guessed.includes(k)){ state.guessed.push(k); if(!state.word.includes(k)) state.wrong++; } }
  }});

  // 13) Connect Four (very basic)
  registerGame('connect4','Connect Four',{cols:7,rows:6}, function(state){ const C=Number(state.opts.cols), R=Number(state.opts.rows); state.board=Array(C*R).fill(0); state.turn=1; function drop(col){ for(let r=R-1;r>=0;r--){ if(!state.board[r*C+col]){ state.board[r*C+col]=state.turn; state.turn=3-state.turn; break } } }
    return { draw(){ ctx.clearRect(0,0,canvas.width,canvas.height); const cell=Math.min(canvas.width/C,canvas.height/R); for(let y=0;y<R;y++) for(let x=0;x<C;x++){ const v=state.board[y*C+x]; ctx.fillStyle=v? (v===1?'red':'yellow'):'#123'; ctx.fillRect(x*cell+5,y*cell+5,cell-8,cell-8) } }, pointerdown(e){ const rect=canvas.getBoundingClientRect(); const x=Math.floor(((e.clientX-rect.left)/canvas.width)*C); drop(x); } }
  });

  // 14) Simon (color memory)
  registerGame('simon','Simon Says',{colors:4,rounds:5}, function(state){ state.seq=[]; state.playIdx=0; state.round=0; state.awaiting=true; state.msg='Press Start'; return {
    draw(){ ctx.clearRect(0,0,canvas.width,canvas.height); ctx.fillStyle='white'; ctx.fillText(state.msg,20,20); const w=canvas.width/2; const h=canvas.height/2; const size=120; for(let i=0;i<4;i++){ ctx.fillStyle=i===state.seq[state.playIdx]? '#7dd3fc':'#114'; const x=60+(i%2)*(size+20); const y=60+Math.floor(i/2)*(size+20); ctx.fillRect(x,y,size,size) } },
    start(){ state.seq=[Math.floor(Math.random()*4)]; state.playIdx=0; state.awaiting=false; state.msg='Watch' },
    pointerdown(e){ state.msg='Clicked!'; }
  }});

  // 15) Typing Test (words per minute)
  registerGame('typing','Typing Test',{duration:10}, function(state){ state.text='the quick brown fox jumps over the lazy dog'; state.idx=0; state.start=0; state.correct=0; return {
    draw(){ ctx.clearRect(0,0,canvas.width,canvas.height); ctx.fillStyle='white'; ctx.fillText(state.text,20,80); ctx.fillText(state.text.slice(0,state.idx),20,110); ctx.fillText('Correct:'+state.correct,20,140) },
    keydown(e){ if(!state.start) state.start=performance.now(); if(e.key.length===1){ if(e.key===state.text[state.idx]) state.correct++; state.idx++; } }
  }});

  // 16) Number Guessing
  registerGame('guess','Number Guessing',{max:100}, function(state){ state.target=Math.floor(Math.random()*Number(state.opts.max))+1; state.msg='Guess a number 1-'+state.opts.max; return {
    draw(){ ctx.clearRect(0,0,canvas.width,canvas.height); ctx.fillStyle='white'; ctx.fillText(state.msg,20,80) },
    keydown(e){ if(e.key==='Enter'){ const i=Number(prompt('Enter guess')); if(i===state.target) state.msg='Correct! New number set'; else state.msg=i<state.target? 'Higher':'Lower' } }
  }});

  // 17) Color Match (press when color matches name)
  registerGame('colormatch','Color Match',{interval:1500}, function(state){ state.timer=0; state.color='red'; state.word='blue'; state.score=0; const cols=['red','green','blue','yellow']; return {
    draw(){ ctx.clearRect(0,0,canvas.width,canvas.height); ctx.fillStyle=state.color; ctx.fillRect(100,80,200,100); ctx.fillStyle='white'; ctx.fillText(state.word,350,120); ctx.fillText('Score:'+state.score,20,20) },
    step(dt){ state.timer+=dt; if(state.timer>Number(state.opts.interval)){ state.timer=0; state.color=cols[Math.floor(Math.random()*cols.length)]; state.word=cols[Math.floor(Math.random()*cols.length)]; } },
    keydown(e){ if(e.key===' '){ if(state.color===state.word) state.score++; else state.score--; } }
  }});

  // 18) Dodger (avoid falling blocks)
  registerGame('dodger','Dodger',{speed:2}, function(state){ state.playerX=canvas.width/2; state.blocks=[]; state.timer=0; state.score=0; return {
    draw(){ ctx.clearRect(0,0,canvas.width,canvas.height); ctx.fillStyle='white'; ctx.fillRect(state.playerX,canvas.height-30,30,20); for(const b of state.blocks) ctx.fillRect(b.x,b.y,20,20); ctx.fillText('Score:'+state.score,10,20) },
    step(dt){ state.timer+=dt; if(state.timer>800){ state.timer=0; state.blocks.push({x:Math.random()*(canvas.width-20),y:-20}) } for(const b of state.blocks) b.y += Number(state.opts.speed); state.blocks=state.blocks.filter(b=>{ if(b.y>canvas.height){ state.score++; return false } return true }); for(const b of state.blocks) if(b.y>canvas.height-40 && Math.abs(b.x-state.playerX)<20) { alert('Hit!'); state.blocks=[]; state.score=0 } },
    pointermove(e){ const rect=canvas.getBoundingClientRect(); state.playerX=e.clientX-rect.left }
  }});

  // 19) Bubble Pop (click bubbles)
  registerGame('bubbles','Bubble Pop',{spawn:700}, function(state){ state.bubbles=[]; state.timer=0; state.score=0; return {
    draw(){ ctx.clearRect(0,0,canvas.width,canvas.height); for(const b of state.bubbles){ ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fillStyle='rgba(125,211,252,0.6)'; ctx.fill() } ctx.fillStyle='white'; ctx.fillText('Score: '+state.score,10,20) },
    step(dt){ state.timer+=dt; if(state.timer>Number(state.opts.spawn)){ state.timer=0; state.bubbles.push({x:Math.random()*canvas.width,y:canvas.height+20,r:20+Math.random()*20,vy:-1.5-Math.random()*1.5}) } for(const b of state.bubbles) b.y+=b.vy; state.bubbles=state.bubbles.filter(b=>b.y+b.r> -10) },
    pointerdown(e){ const rect=canvas.getBoundingClientRect(); const x=e.clientX-rect.left,y=e.clientY-rect.top; for(let i=state.bubbles.length-1;i>=0;i--){ const b=state.bubbles[i]; if(Math.hypot(b.x-x,b.y-y)<b.r){ state.bubbles.splice(i,1); state.score++; break } } }
  }});

  // 20) Simple Space Shooter
  registerGame('shooter','Space Shooter',{bulletSpeed:6}, function(state){ state.shipX=canvas.width/2; state.bullets=[]; state.enemies=[]; state.spawn=0; state.score=0; return {
    draw(){ ctx.clearRect(0,0,canvas.width,canvas.height); ctx.fillStyle='white'; ctx.fillRect(state.shipX,canvas.height-30,20,20); for(const b of state.bullets) ctx.fillRect(b.x,b.y,4,8); for(const e of state.enemies) ctx.fillRect(e.x,e.y,24,16); ctx.fillText('Score:'+state.score,10,20) },
    step(dt){ state.spawn+=dt; if(state.spawn>1500){ state.spawn=0; state.enemies.push({x:Math.random()*(canvas.width-24),y:-20,vy:1+Math.random()*1.5}) } for(const e of state.enemies) e.y+=e.vy; for(const b of state.bullets) b.y-=Number(state.opts.bulletSpeed); // collisions
      for(let i=state.enemies.length-1;i>=0;i--){ const e=state.enemies[i]; for(let j=state.bullets.length-1;j>=0;j--){ const b=state.bullets[j]; if(b.x>e.x && b.x<e.x+24 && b.y>e.y && b.y<e.y+16){ state.enemies.splice(i,1); state.bullets.splice(j,1); state.score++; break } } } state.enemies=state.enemies.filter(e=>e.y<canvas.height+50); state.bullets=state.bullets.filter(b=>b.y>-20) },
    pointermove(e){ const rect=canvas.getBoundingClientRect(); state.shipX=e.clientX-rect.left }, keydown(e){ if(e.key===' ') state.bullets.push({x:state.shipX+8,y:canvas.height-40}) }
  }});

  // 21) Maze Runner (random obstacles)
  registerGame('maze','Maze Runner',{speed:3}, function(state){ state.player={x:20,y:20}; state.walls=[]; for(let i=0;i<40;i++) state.walls.push({x:Math.random()*(canvas.width-40),y:Math.random()*(canvas.height-40),w:20,h:20}); return {
    draw(){ ctx.clearRect(0,0,canvas.width,canvas.height); ctx.fillStyle='white'; ctx.fillRect(state.player.x,state.player.y,12,12); for(const w of state.walls) ctx.fillRect(w.x,w.y,w.w,w.h) },
    keydown(e){ if(e.key==='ArrowUp') state.player.y-=Number(state.opts.speed); if(e.key==='ArrowDown') state.player.y+=Number(state.opts.speed); if(e.key==='ArrowLeft') state.player.x-=Number(state.opts.speed); if(e.key==='ArrowRight') state.player.x+=Number(state.opts.speed); }
  }});

  // 22) Memory Match (pairs)
  registerGame('match','Memory Match',{pairs:8}, function(state){ const P=Number(state.opts.pairs); state.cards=[]; for(let i=0;i<P;i++){ state.cards.push(i); state.cards.push(i) } state.cards.sort(()=>Math.random()-0.5); state.revealed=[]; state.matched=[]; return {
    draw(){ ctx.clearRect(0,0,canvas.width,canvas.height); const cols=6; const cell=60; for(let i=0;i<state.cards.length;i++){ const x=10+(i%cols)*cell, y=10+Math.floor(i/cols)*cell; if(state.matched.includes(i) || state.revealed.includes(i)){ ctx.fillStyle='#7dd3fc'; ctx.fillRect(x,y,50,50); ctx.fillStyle='black'; ctx.fillText(state.cards[i],x+20,y+30) } else { ctx.fillStyle='#123'; ctx.fillRect(x,y,50,50) } } },
    pointerdown(e){ const rect=canvas.getBoundingClientRect(); const x=Math.floor(((e.clientX-rect.left)-10)/60), y=Math.floor(((e.clientY-rect.top)-10)/60); const i=y*6+x; if(i<0||i>=state.cards.length) return; if(state.revealed.includes(i) || state.matched.includes(i)) return; state.revealed.push(i); if(state.revealed.length===2){ const a=state.revealed[0], b=state.revealed[1]; if(state.cards[a]===state.cards[b]){ state.matched.push(a); state.matched.push(b) } setTimeout(()=>state.revealed=[],600) } }
  }});

  // 23) Lights Out (toggle)
  registerGame('lights','Lights Out',{size:5}, function(state){ const N=Number(state.opts.size); state.grid=Array(N*N).fill(0).map(()=>Math.random()>0.5?1:0); return {
    draw(){ ctx.clearRect(0,0,canvas.width,canvas.height); const cell=canvas.width/N; for(let y=0;y<N;y++) for(let x=0;x<N;x++){ ctx.fillStyle=state.grid[y*N+x]? '#ffea00':'#123'; ctx.fillRect(x*cell,y*cell,cell-2,cell-2) } },
    pointerdown(e){ const rect=canvas.getBoundingClientRect(); const x=Math.floor(((e.clientX-rect.left)/canvas.width)*N), y=Math.floor(((e.clientY-rect.top)/canvas.height)*N); const idx=y*N+x; const coords=[[0,0],[1,0],[-1,0],[0,1],[0,-1]]; for(const c of coords){ const nx=x+c[0], ny=y+c[1]; if(nx>=0&&ny>=0&&nx<N&&ny<N) state.grid[ny*N+nx]^=1 } }
  }});

  // 24) Coin Flip
  registerGame('coin','Coin Flip',{bias:0.5}, function(state){ state.last=''; return {
    draw(){ ctx.clearRect(0,0,canvas.width,canvas.height); ctx.fillStyle='white'; ctx.fillText('Last: '+state.last,20,40); },
    pointerdown(){ state.last = Math.random()<Number(state.opts.bias)? 'Heads':'Tails' }
  }});

  // 25) Stopwatch / Timer
  registerGame('stopwatch','Stopwatch',{mode:'stopwatch'}, function(state){ state.t=0; state.running=false; return {
    draw(){ ctx.clearRect(0,0,canvas.width,canvas.height); ctx.fillStyle='white'; ctx.fillText((state.t/1000).toFixed(2)+'s',20,40) },
    start(){ state.running=true }, stop(){ state.running=false }, reset(){ state.t=0 }, step(dt){ if(state.running) state.t+=dt }
  }});

  // --- UI plumbing ---
  const gameListEl = qs('#gameList'); const gameSettingsEl = qs('#gameSettings'); const activeName = qs('#activeGameName'); let activeGame=null; let activeInstance=null; let state=null;

  function buildGameButtons(){ games.forEach(g=>{ const btn=document.createElement('button'); btn.textContent=g.name; btn.dataset.id=g.id; btn.addEventListener('click',()=>selectGame(g.id)); gameListEl.appendChild(btn) }) }
  function selectGame(id){ document.querySelectorAll('#gameList button').forEach(b=>b.classList.toggle('active',b.dataset.id===id)); activeGame = games.find(g=>g.id===id); activeName.textContent = activeGame.name; buildGameSettings(); }

  function buildGameSettings(){ gameSettingsEl.innerHTML=''; const g=activeGame; const opts = g.defaults; const form=document.createElement('div'); for(const k in opts){ const label=document.createElement('label'); label.textContent=k; const input=document.createElement('input'); input.value=opts[k]; input.dataset.key=k; input.addEventListener('input',()=>{}) ; label.appendChild(input); form.appendChild(label) } const custom=document.createElement('div'); custom.style.marginTop='8px'; custom.innerHTML='<button id="saveGameOpts">Save</button> <button id="resetGameOpts">Reset</button>';
    gameSettingsEl.appendChild(form); gameSettingsEl.appendChild(custom);
    qs('#saveGameOpts').addEventListener('click',()=>{ // gather
      const inputs = Array.from(form.querySelectorAll('input')); activeGame._lastOpts = {}; inputs.forEach(i=> activeGame._lastOpts[i.dataset.key]=i.value); alert('Saved settings for '+activeGame.name) });
    qs('#resetGameOpts').addEventListener('click',()=>{ Array.from(form.querySelectorAll('input')).forEach((i)=> i.value=activeGame.defaults[i.dataset.key]) });
  }

  qs('#applyCanvas').addEventListener('click',()=>{ const w=Number(qs('#canvasWidth').value); const h=Number(qs('#canvasHeight').value); const s=Number(qs('#canvasScale').value); canvas.width=w; canvas.height=h; canvas.style.width=(w*s)+'px'; canvas.style.height=(h*s)+'px'; });
  qs('#resetSettings').addEventListener('click',()=>{ qs('#canvasWidth').value=640; qs('#canvasHeight').value=360; qs('#canvasScale').value=1; canvas.width=640; canvas.height=360; canvas.style.width='640px'; canvas.style.height='360px'; });

  function randomRange(a,b){ return Math.floor(Math.random()*(b-a))+a }

  buildGameButtons(); selectGame(games[0].id);

  function createInstance(){ if(!activeGame) return; state={opts: {...activeGame.defaults, ...(activeGame._lastOpts||{})}}; activeInstance = activeGame.setupFn(state) || {}; // allow start
    if(activeInstance.start) activeInstance.start(); }

  function destroyInstance(){ if(activeInstance && activeInstance.stop) activeInstance.stop(); activeInstance=null; state=null; }

  function loop(ts){ const dt = lastTs? Math.min(40, ts-lastTs) : 16; lastTs=ts; if(activeInstance && activeInstance.step) activeInstance.step(dt); if(activeInstance && activeInstance.draw) activeInstance.draw(); animationId=requestAnimationFrame(loop); }
  let lastTs=null;

  qs('#startBtn').addEventListener('click',()=>{ destroyInstance(); createInstance(); if(!animationId) { lastTs=0; animationId=requestAnimationFrame(loop) } });
  qs('#stopBtn').addEventListener('click',()=>{ if(animationId) cancelAnimationFrame(animationId); animationId=null; destroyInstance(); });

  // global input routing
  window.addEventListener('keydown',(e)=>{ if(activeInstance && activeInstance.keydown) activeInstance.keydown(e); });
  canvas.addEventListener('pointerdown',(e)=>{ if(activeInstance && activeInstance.pointerdown) activeInstance.pointerdown(e); });
  canvas.addEventListener('pointermove',(e)=>{ if(activeInstance && activeInstance.pointermove) activeInstance.pointermove(e); });

  // dynamic UI injection for small games needing buttons
  qs('#gameList').addEventListener('click',(e)=>{ if(e.target.tagName==='BUTTON'){ setTimeout(()=>{ const ui = (activeGame && activeGame._lastOpts)? '': ''; qs('#extraUI').innerHTML = ''; // some games provide ui via instance.ui
      if(activeInstance && activeInstance.ui) qs('#extraUI').innerHTML = activeInstance.ui(); } ,100) } });

  // small hook: after saving options, auto-create instance to pick them up
  document.addEventListener('click',(e)=>{ if(e.target && e.target.matches('button[data-move]')){ const m=e.target.dataset.move; const comp = {R:0,P:1,S:2}; const cpu=Math.floor(Math.random()*3); const mapping=['Rock','Paper','Scissors']; alert('You: '+mapping[comp[m]]+' CPU: '+mapping[cpu]+' => '+( (comp[m]===cpu)?'Tie':( (comp[m]+1)%3===cpu? 'CPU wins':'You win') ) ) } });

  // select first game and draw initial
  createInstance(); if(activeInstance && activeInstance.draw) activeInstance.draw();
  </script>
</body>
</html>
