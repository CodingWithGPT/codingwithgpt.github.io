<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Tetris - PC & iPad</title>
<style>
  * {
    box-sizing: border-box;
  }
  body {
    background: #111827;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
    height: 100vh;
    margin: 0;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    color: #e5e7eb;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
  }
  h1 {
    margin: 1rem 0 0.5rem;
    font-weight: 700;
  }
  #game-container {
    display: flex;
    gap: 20px;
    margin-bottom: 1rem;
    user-select: none;
  }
  canvas {
    background: #1f2937;
    border-radius: 8px;
    box-shadow: 0 0 15px #2563eb;
  }
  #game {
    image-rendering: pixelated;
  }
  #next {
    image-rendering: pixelated;
    background: #1f2937;
    border-radius: 8px;
    box-shadow: 0 0 15px #2563eb;
  }
  #sidebar {
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    color: #cbd5e1;
  }
  #score, #level {
    font-size: 1.2rem;
    margin-bottom: 1rem;
  }
  #instructions {
    font-size: 0.9rem;
    max-width: 220px;
    background: #374151;
    padding: 1rem;
    border-radius: 8px;
    box-shadow: 0 0 10px #2563ebaa;
  }
  #instructions h2 {
    margin-top: 0;
    margin-bottom: 0.5rem;
    color: #60a5fa;
  }
  /* Touch controls UI */
  #touch-controls {
    display: none;
    position: fixed;
    bottom: 10px;
    width: 100%;
    max-width: 500px;
    left: 50%;
    transform: translateX(-50%);
    justify-content: space-around;
    pointer-events: none;
  }
  #touch-controls > button {
    pointer-events: auto;
    background: #2563ebaa;
    border: none;
    border-radius: 50%;
    width: 56px;
    height: 56px;
    color: white;
    font-size: 24px;
    font-weight: bold;
    user-select: none;
    box-shadow: 0 0 10px #2563eb;
  }
  #touch-controls > button:active {
    background: #1d4ed8;
  }

  @media (hover: none) and (pointer: coarse) {
    #touch-controls {
      display: flex;
    }
    #instructions {
      max-width: 100%;
      margin: 1rem;
    }
  }
</style>
</head>
<body>

<h1>Tetris</h1>

<div id="game-container">
  <canvas id="game" width="240" height="400" aria-label="Tetris game board" role="application" tabindex="0"></canvas>
  <div id="sidebar">
    <canvas id="next" width="120" height="120" aria-label="Next piece preview"></canvas>
    <div id="score">Score: 0</div>
    <div id="level">Level: 1</div>
    <div id="instructions">
      <h2>Controls</h2>
      <strong>PC:</strong><br/>
      ← →: Move | ↑ or Space: Rotate | ↓: Soft Drop<br/><br/>
      <strong>iPad/Mobile:</strong><br/>
      Swipe Left/Right: Move<br/>
      Tap: Rotate<br/>
      Swipe Down: Soft Drop
    </div>
  </div>
</div>

<!-- Touch controls for mobile -->
<div id="touch-controls" aria-label="Touch controls for Tetris">
  <button id="btn-left" aria-label="Move left">◀</button>
  <button id="btn-rotate" aria-label="Rotate piece">⟳</button>
  <button id="btn-right" aria-label="Move right">▶</button>
  <button id="btn-down" aria-label="Soft drop">▼</button>
</div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const nextCanvas = document.getElementById('next');
  const nextCtx = nextCanvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const levelEl = document.getElementById('level');

  const ROWS = 20;
  const COLS = 10;
  const BLOCK_SIZE = 20;

  // Colors for pieces
  const COLORS = [
    null,
    '#2563eb', // I - Blue
    '#d97706', // L - Orange
    '#16a34a', // S - Green
    '#b91c1c', // Z - Red
    '#7c3aed', // T - Purple
    '#ca8a04', // J - Yellow-orange
    '#0ea5e9'  // O - Cyan
  ];

  // Tetromino shapes (4x4 grids)
  const SHAPES = {
    I: [
      [0,0,0,0],
      [1,1,1,1],
      [0,0,0,0],
      [0,0,0,0]
    ],
    J: [
      [2,0,0],
      [2,2,2],
      [0,0,0]
    ],
    L: [
      [0,0,3],
      [3,3,3],
      [0,0,0]
    ],
    O: [
      [4,4],
      [4,4]
    ],
    S: [
      [0,5,5],
      [5,5,0],
      [0,0,0]
    ],
    T: [
      [0,6,0],
      [6,6,6],
      [0,0,0]
    ],
    Z: [
      [7,7,0],
      [0,7,7],
      [0,0,0]
    ]
  };

  const PIECES = 'IJLOSZT';

  // Game state
  let board = [];
  let currentPiece = null;
  let currentPos = {x:0, y:0};
  let nextPiece = null;
  let dropCounter = 0;
  let dropInterval = 1000; // ms, speed
  let lastTime = 0;
  let score = 0;
  let level = 1;
  let linesCleared = 0;
  let gameOver = false;

  // Initialize board with zeros
  function createBoard() {
    board = [];
    for(let r=0; r<ROWS; r++) {
      const row = [];
      for(let c=0; c<COLS; c++) row.push(0);
      board.push(row);
    }
  }

  // Draw a single block at (x,y) in board coords
  function drawBlock(x, y, colorIndex) {
    ctx.fillStyle = COLORS[colorIndex] || 'transparent';
    ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
    ctx.strokeStyle = '#111827';
    ctx.lineWidth = 2;
    ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
  }

  // Draw the whole board
  function drawBoard() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for(let r=0; r<ROWS; r++) {
      for(let c=0; c<COLS; c++) {
        if(board[r][c] !== 0) {
          drawBlock(c, r, board[r][c]);
        } else {
          // Draw empty cell background for contrast
          ctx.fillStyle = '#1f2937';
          ctx.fillRect(c*BLOCK_SIZE, r*BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
          ctx.strokeStyle = '#111827';
          ctx.lineWidth = 1;
          ctx.strokeRect(c*BLOCK_SIZE, r*BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
        }
      }
    }
  }

  // Draw the current piece on top of board
  function drawPiece(piece, pos) {
    const shape = piece.shape;
    for(let r=0; r<shape.length; r++) {
      for(let c=0; c<shape[r].length; c++) {
        if(shape[r][c]) {
          drawBlock(pos.x + c, pos.y + r, piece.color);
        }
      }
    }
  }

  // Clear next piece preview
  function drawNextPiece() {
    nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
    if (!nextPiece) return;
    const shape = nextPiece.shape;
    const size = BLOCK_SIZE;
    nextCtx.fillStyle = '#1f2937';
    nextCtx.fillRect(0, 0, nextCanvas.width, nextCanvas.height);

    for(let r=0; r<shape.length; r++) {
      for(let c=0; c<shape[r].length; c++) {
        if(shape[r][c]) {
          nextCtx.fillStyle = COLORS[nextPiece.color] || 'transparent';
          nextCtx.fillRect(c * size + 10, r * size + 10, size-2, size-2);
          nextCtx.strokeStyle = '#111827';
          nextCtx.lineWidth = 2;
          nextCtx.strokeRect(c * size + 10, r * size + 10, size-2, size-2);
        }
      }
    }
  }

  // Create a new random piece
  function createPiece() {
    const type = PIECES[Math.floor(Math.random() * PIECES.length)];
    const shape = SHAPES[type];
    const colorIndex = PIECES.indexOf(type) + 1;
    return { shape, color: colorIndex };
  }

  // Rotate matrix 90 deg clockwise
  function rotate(matrix) {
    const N = matrix.length;
    const result = [];
    for(let i=0; i<N; i++) result.push(new Array(N).fill(0));
    for(let r=0; r<N; r++) {
      for(let c=0; c<N; c++) {
        result[c][N - 1 - r] = matrix[r][c];
      }
    }
    return result;
  }

  // Check if piece fits in board at pos
  function validPosition(piece, pos) {
    const shape = piece.shape;
    for(let r=0; r<shape.length; r++) {
      for(let c=0; c<shape[r].length; c++) {
        if(shape[r][c]) {
          const x = pos.x + c;
          const y = pos.y + r;
          if(x < 0 || x >= COLS || y >= ROWS) return false;
          if(y >= 0 && board[y][x] !== 0) return false;
        }
      }
    }
    return true;
  }

  // Merge piece into board permanently
  function placePiece(piece, pos) {
    const shape = piece.shape;
    for(let r=0; r<shape.length; r++) {
      for(let c=0; c<shape[r].length; c++) {
        if(shape[r][c]) {
          const x = pos.x + c;
          const y = pos.y + r;
          if(y >= 0) board[y][x] = piece.color;
        }
      }
    }
  }

  // Clear full lines
  function clearLines() {
    let linesCleared = 0;
    outer: for(let r=ROWS-1; r>=0; r--) {
      for(let c=0; c<COLS; c++) {
        if(board[r][c] === 0) continue outer;
      }
      // Remove this row
      board.splice(r, 1);
      // Add empty row at top
      board.unshift(new Array(COLS).fill(0));
      linesCleared++;
      r++; // Check same row again as rows moved down
    }
    return linesCleared;
  }

  // Update score based on lines cleared
  function updateScore(lines) {
    const linePoints = [0, 40, 100, 300, 1200];
    score += linePoints[lines] * level;
    if(score < 0) score = 0;
    scoreEl.textContent = 'Score: ' + score;
  }

  // Increase level every 10 lines cleared, speed up drop
  function updateLevel(lines) {
    if(lines > 0) {
      linesCleared += lines;
      const newLevel = Math.floor(linesCleared / 10) + 1;
      if(newLevel > level) {
        level = newLevel;
        dropInterval = Math.max(100, 1000 - (level - 1) * 100);
        levelEl.textContent = 'Level: ' + level;
      }
    }
  }

  // Game over screen
  function gameOverScreen() {
    ctx.fillStyle = 'rgba(0,0,0,0.75)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = 'white';
    ctx.font = 'bold 36px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Game Over', canvas.width/2, canvas.height/2);
  }

  // Drop piece down one
  function drop() {
    if(gameOver) return;
    const newPos = {x: currentPos.x, y: currentPos.y + 1};
    if(validPosition(currentPiece, newPos)) {
      currentPos = newPos;
    } else {
      // Place piece
      placePiece(currentPiece, currentPos);
      // Clear lines
      const lines = clearLines();
      updateScore(lines);
      updateLevel(lines);
      // Next piece becomes current
      currentPiece = nextPiece;
      nextPiece = createPiece();
      currentPos = {x: Math.floor((COLS - currentPiece.shape[0].length) / 2), y: -getTopOffset(currentPiece)};
      if(!validPosition(currentPiece, currentPos)) {
        gameOver = true;
        gameOverScreen();
        return;
      }
      drawNextPiece();
    }
  }

  // Returns offset of empty rows at top of piece matrix
  function getTopOffset(piece) {
    const shape = piece.shape;
    for(let r=0; r<shape.length; r++) {
      for(let c=0; c<shape[r].length; c++) {
        if(shape[r][c]) return r;
      }
    }
    return 0;
  }

  // Move piece left/right
  function move(dir) {
    if(gameOver) return;
    const newPos = {x: currentPos.x + dir, y: currentPos.y};
    if(validPosition(currentPiece, newPos)) {
      currentPos = newPos;
    }
  }

  // Rotate piece with wall kicks
  function rotatePiece() {
    if(gameOver) return;
    const rotatedShape = rotate(currentPiece.shape);
    const testPiece = {...currentPiece, shape: rotatedShape};
    const kicks = [0, -1, 1, -2, 2];
    for(const kick of kicks) {
      const newPos = {x: currentPos.x + kick, y: currentPos.y};
      if(validPosition(testPiece, newPos)) {
        currentPiece.shape = rotatedShape;
        currentPos = newPos;
        break;
      }
    }
  }

  // Draw everything
  function draw() {
    drawBoard();
    if(!gameOver) drawPiece(currentPiece, currentPos);
  }

  // Animation loop
  function update(time=0) {
    if(gameOver) return;
    const delta = time - lastTime;
    dropCounter += delta;
    if(dropCounter > dropInterval) {
      drop();
      dropCounter = 0;
    }
    lastTime = time;
    draw();
    requestAnimationFrame(update);
  }

  // Setup initial game
  function init() {
    createBoard();
    score = 0;
    level = 1;
    linesCleared = 0;
    dropInterval = 1000;
    gameOver = false;
    scoreEl.textContent = 'Score: 0';
    levelEl.textContent = 'Level: 1';
    currentPiece = createPiece();
    nextPiece = createPiece();
    currentPos = {x: Math.floor((COLS - currentPiece.shape[0].length) / 2), y: -getTopOffset(currentPiece)};
    drawNextPiece();
    lastTime = 0;
    dropCounter = 0;
    requestAnimationFrame(update);
  }

  // Keyboard controls
  window.addEventListener('keydown', e => {
    if(gameOver) return;
    switch(e.key) {
      case 'ArrowLeft':
        move(-1);
        break;
      case 'ArrowRight':
        move(1);
        break;
      case 'ArrowUp':
      case ' ':
        e.preventDefault();
        rotatePiece();
        break;
      case 'ArrowDown':
        drop();
        break;
    }
  });

  // Touch controls for iPad/mobile
  let touchStartX = null;
  let touchStartY = null;
  let touchMoved = false;

  canvas.addEventListener('touchstart', (e) => {
    if(gameOver) return;
    touchMoved = false;
    const touch = e.touches[0];
    touchStartX = touch.clientX;
    touchStartY = touch.clientY;
  });

  canvas.addEventListener('touchmove', (e) => {
    if(gameOver) return;
    if(!touchStartX || !touchStartY) return;
    const touch = e.touches[0];
    const dx = touch.clientX - touchStartX;
    const dy = touch.clientY - touchStartY;

    // Threshold for swipe detection
    const threshold = 30;

    if(!touchMoved) {
      if(Math.abs(dx) > threshold) {
        if(dx > 0) move(1);
        else move(-1);
        touchMoved = true;
        touchStartX = touch.clientX;
        touchStartY = touch.clientY;
      } else if(dy > threshold) {
        drop();
        touchMoved = true;
        touchStartX = touch.clientX;
        touchStartY = touch.clientY;
      }
    }
  });

  canvas.addEventListener('touchend', (e) => {
    if(gameOver) return;
    if(!touchMoved) {
      // Tap detected, rotate piece
      rotatePiece();
    }
    touchStartX = null;
    touchStartY = null;
    touchMoved = false;
  });

  // Buttons on-screen for touch
  document.getElementById('btn-left').addEventListener('touchstart', (e) => {
    e.preventDefault();
    if(gameOver) return;
    move(-1);
  });
  document.getElementById('btn-right').addEventListener('touchstart', (e) => {
    e.preventDefault();
    if(gameOver) return;
    move(1);
  });
  document.getElementById('btn-rotate').addEventListener('touchstart', (e) => {
    e.preventDefault();
    if(gameOver) return;
    rotatePiece();
  });
  document.getElementById('btn-down').addEventListener('touchstart', (e) => {
    e.preventDefault();
    if(gameOver) return;
    drop();
  });

  // Start game
  init();

})();
</script>

</body>
</html>
